<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.48 with theme Tranquilpeak 0.4.3-SNAPSHOT">
<meta name="author" content="">
<meta name="keywords" content=", development, next-gen">
<meta name="description" content="Debuging 调试在编程工作中很常见，几乎每天都会很它打交道。可以说对于编程人员来说是一件很困扰的事情，有时候查找一个 Bug 原因，需要花费大量的时间和精力。
本书一共总结了调试规则九则：
1.理解系统
2.制造失败
3.不要想，而要看
4.分而治之
5.一次只改一个地方
6.保持审计跟踪
7.检查插头
8.获得全新观点
9.如果你不修复 Bug，它将依然存在
单看这 9 个规则的标题，会有熟悉的感觉吧，会不会跟自己平时调试的时候，有一些方法差不多，觉得很简单。那回想一下，这些简单的规则，是否都能用对地方呢，是否在关键的时候，想的到呢？
其实在实际工作中，有时候越简单的规则往往越被人忽略。有些规则显而易见，会记得运用在特定的问题上，越往往不容易；有时候会被人忽视，有时候会走所谓的捷径，最终所花的时间越久。所以看的过程中，有时候会产生共鸣；有时候会暗自懊悔，自己为什么当时没有使用这种调试方法，所以要记住并运用好这些规则会很有帮助。
读这本书并写下读书笔记，最主要的是想提高自己的调试能力，提高工作效率；当然也能节省下来时间去做其他的事情。 书中每个规则里面都有详细细分了规则使用的不同情况，还有举例说明。我把自己在看书过程中的想法记录一下，加深下对于规则的理解，以便更好的运用到工作生活中去。
理解系统 项目已经到了中后期，基本每天会被分配到不同的 Bug，有时候会接到自己不熟悉的功能 Bug，接到这样的 Bug，首先要做的工作就是理解系统。
理解系统就是你必须掌握系统的工作原理以及它是如何设计的，在某些情况下，还要知道为什么这么设计，如果你没有理解系统的某个部分，那么通常就是出问题的地方。
『昨天我在查找一个 Bug 的原因：我查找到在跟 AI 一起比赛时，对方使用的 Buff 跟显示出来的一致；跟真实的玩家比赛时，对方使用的 Buff 跟显示出来的不一致。我咨询了主程 AI 跟真实玩家的数据上的区别：AI 的 Buff 使用是纯客户端处理，而真实的玩家需要发送给服务端，服务端会再进行计算，再分发给其他玩家的。我断定问题出在服务器那边。最后结果肯定不是服务端的问题，问题出在客户端读取服务端的一个类型 type 上，type 并不是 BuffType 而是需要做一个类型转换，之前直接当做 BuffType 接收的，所以会出现对方使用跟显示不一致的问题。』
上面的事例中我忽略了一个错误，就是没有理解系统，我没有去查看这个功能的数据接口相关的文档说明，导致了判断错误。
在开发的过程中，在接触到新的功能时、修改 Bug，容易犯经验主义错误，没有仔细的看相关文档，导致最后漏掉功能细节，或者修改 Bug 不彻底，甚至找不到出现 Bug 原因。
理解系统可以通过以下几方面来做：
1.阅读手册，手册里会告诉你正确的使用方法；
2.逐字逐句的阅读整个手册，解决问题的方法可能就隐藏在不起眼的角落；
3.知道什么是正常的，即必须掌握你所工作技术领悟内的基础知识，才能知道什么是正常的；
4.知道工作流程：当你尝试查找错误时，必须知道要查找的路线；
5.调试工具是用来观察系统的眼和耳，你必须选择正确的工具，正确地使用工具，并正确地解释得到的结果；你越是精通工具，就越容易查明系统中发生了什么事情；
6.了解你的工具：调试工具是用来观察系统的眼和耳，你必须选择正确的调试工具，正确的使用工具，并正确的解释得到的结果。还要必须了解工具的局限性，可以显示什么错误，不能显示什么错误。还必须了解开发工具，所使用的编程语言；
7.在项目中，对一个组件或者语法的运用有分歧，不要盲目的相信自己的记忆力，不要猜测，去查阅手册，要养成良好的查阅习惯。
制造失败 有时候理解了系统，还是锁定不了 Bug 的来源，这时候就需要执行下一个方案了。
1.制造失败：顾名思义就是把失败再重复一遍，或者几遍。
为什么要制作失败呢？">


<meta property="og:description" content="Debuging 调试在编程工作中很常见，几乎每天都会很它打交道。可以说对于编程人员来说是一件很困扰的事情，有时候查找一个 Bug 原因，需要花费大量的时间和精力。
本书一共总结了调试规则九则：
1.理解系统
2.制造失败
3.不要想，而要看
4.分而治之
5.一次只改一个地方
6.保持审计跟踪
7.检查插头
8.获得全新观点
9.如果你不修复 Bug，它将依然存在
单看这 9 个规则的标题，会有熟悉的感觉吧，会不会跟自己平时调试的时候，有一些方法差不多，觉得很简单。那回想一下，这些简单的规则，是否都能用对地方呢，是否在关键的时候，想的到呢？
其实在实际工作中，有时候越简单的规则往往越被人忽略。有些规则显而易见，会记得运用在特定的问题上，越往往不容易；有时候会被人忽视，有时候会走所谓的捷径，最终所花的时间越久。所以看的过程中，有时候会产生共鸣；有时候会暗自懊悔，自己为什么当时没有使用这种调试方法，所以要记住并运用好这些规则会很有帮助。
读这本书并写下读书笔记，最主要的是想提高自己的调试能力，提高工作效率；当然也能节省下来时间去做其他的事情。 书中每个规则里面都有详细细分了规则使用的不同情况，还有举例说明。我把自己在看书过程中的想法记录一下，加深下对于规则的理解，以便更好的运用到工作生活中去。
理解系统 项目已经到了中后期，基本每天会被分配到不同的 Bug，有时候会接到自己不熟悉的功能 Bug，接到这样的 Bug，首先要做的工作就是理解系统。
理解系统就是你必须掌握系统的工作原理以及它是如何设计的，在某些情况下，还要知道为什么这么设计，如果你没有理解系统的某个部分，那么通常就是出问题的地方。
『昨天我在查找一个 Bug 的原因：我查找到在跟 AI 一起比赛时，对方使用的 Buff 跟显示出来的一致；跟真实的玩家比赛时，对方使用的 Buff 跟显示出来的不一致。我咨询了主程 AI 跟真实玩家的数据上的区别：AI 的 Buff 使用是纯客户端处理，而真实的玩家需要发送给服务端，服务端会再进行计算，再分发给其他玩家的。我断定问题出在服务器那边。最后结果肯定不是服务端的问题，问题出在客户端读取服务端的一个类型 type 上，type 并不是 BuffType 而是需要做一个类型转换，之前直接当做 BuffType 接收的，所以会出现对方使用跟显示不一致的问题。』
上面的事例中我忽略了一个错误，就是没有理解系统，我没有去查看这个功能的数据接口相关的文档说明，导致了判断错误。
在开发的过程中，在接触到新的功能时、修改 Bug，容易犯经验主义错误，没有仔细的看相关文档，导致最后漏掉功能细节，或者修改 Bug 不彻底，甚至找不到出现 Bug 原因。
理解系统可以通过以下几方面来做：
1.阅读手册，手册里会告诉你正确的使用方法；
2.逐字逐句的阅读整个手册，解决问题的方法可能就隐藏在不起眼的角落；
3.知道什么是正常的，即必须掌握你所工作技术领悟内的基础知识，才能知道什么是正常的；
4.知道工作流程：当你尝试查找错误时，必须知道要查找的路线；
5.调试工具是用来观察系统的眼和耳，你必须选择正确的工具，正确地使用工具，并正确地解释得到的结果；你越是精通工具，就越容易查明系统中发生了什么事情；
6.了解你的工具：调试工具是用来观察系统的眼和耳，你必须选择正确的调试工具，正确的使用工具，并正确的解释得到的结果。还要必须了解工具的局限性，可以显示什么错误，不能显示什么错误。还必须了解开发工具，所使用的编程语言；
7.在项目中，对一个组件或者语法的运用有分歧，不要盲目的相信自己的记忆力，不要猜测，去查阅手册，要养成良好的查阅习惯。
制造失败 有时候理解了系统，还是锁定不了 Bug 的来源，这时候就需要执行下一个方案了。
1.制造失败：顾名思义就是把失败再重复一遍，或者几遍。
为什么要制作失败呢？">
<meta property="og:type" content="article">
<meta property="og:title" content="调试九法">
<meta name="twitter:title" content="调试九法">
<meta property="og:url" content="https://yuyaoxue.github.io/post/2018-05-27-debuging/">
<meta property="twitter:url" content="https://yuyaoxue.github.io/post/2018-05-27-debuging/">
<meta property="og:site_name" content="薛玉瑶的博客">
<meta property="og:description" content="Debuging 调试在编程工作中很常见，几乎每天都会很它打交道。可以说对于编程人员来说是一件很困扰的事情，有时候查找一个 Bug 原因，需要花费大量的时间和精力。
本书一共总结了调试规则九则：
1.理解系统
2.制造失败
3.不要想，而要看
4.分而治之
5.一次只改一个地方
6.保持审计跟踪
7.检查插头
8.获得全新观点
9.如果你不修复 Bug，它将依然存在
单看这 9 个规则的标题，会有熟悉的感觉吧，会不会跟自己平时调试的时候，有一些方法差不多，觉得很简单。那回想一下，这些简单的规则，是否都能用对地方呢，是否在关键的时候，想的到呢？
其实在实际工作中，有时候越简单的规则往往越被人忽略。有些规则显而易见，会记得运用在特定的问题上，越往往不容易；有时候会被人忽视，有时候会走所谓的捷径，最终所花的时间越久。所以看的过程中，有时候会产生共鸣；有时候会暗自懊悔，自己为什么当时没有使用这种调试方法，所以要记住并运用好这些规则会很有帮助。
读这本书并写下读书笔记，最主要的是想提高自己的调试能力，提高工作效率；当然也能节省下来时间去做其他的事情。 书中每个规则里面都有详细细分了规则使用的不同情况，还有举例说明。我把自己在看书过程中的想法记录一下，加深下对于规则的理解，以便更好的运用到工作生活中去。
理解系统 项目已经到了中后期，基本每天会被分配到不同的 Bug，有时候会接到自己不熟悉的功能 Bug，接到这样的 Bug，首先要做的工作就是理解系统。
理解系统就是你必须掌握系统的工作原理以及它是如何设计的，在某些情况下，还要知道为什么这么设计，如果你没有理解系统的某个部分，那么通常就是出问题的地方。
『昨天我在查找一个 Bug 的原因：我查找到在跟 AI 一起比赛时，对方使用的 Buff 跟显示出来的一致；跟真实的玩家比赛时，对方使用的 Buff 跟显示出来的不一致。我咨询了主程 AI 跟真实玩家的数据上的区别：AI 的 Buff 使用是纯客户端处理，而真实的玩家需要发送给服务端，服务端会再进行计算，再分发给其他玩家的。我断定问题出在服务器那边。最后结果肯定不是服务端的问题，问题出在客户端读取服务端的一个类型 type 上，type 并不是 BuffType 而是需要做一个类型转换，之前直接当做 BuffType 接收的，所以会出现对方使用跟显示不一致的问题。』
上面的事例中我忽略了一个错误，就是没有理解系统，我没有去查看这个功能的数据接口相关的文档说明，导致了判断错误。
在开发的过程中，在接触到新的功能时、修改 Bug，容易犯经验主义错误，没有仔细的看相关文档，导致最后漏掉功能细节，或者修改 Bug 不彻底，甚至找不到出现 Bug 原因。
理解系统可以通过以下几方面来做：
1.阅读手册，手册里会告诉你正确的使用方法；
2.逐字逐句的阅读整个手册，解决问题的方法可能就隐藏在不起眼的角落；
3.知道什么是正常的，即必须掌握你所工作技术领悟内的基础知识，才能知道什么是正常的；
4.知道工作流程：当你尝试查找错误时，必须知道要查找的路线；
5.调试工具是用来观察系统的眼和耳，你必须选择正确的工具，正确地使用工具，并正确地解释得到的结果；你越是精通工具，就越容易查明系统中发生了什么事情；
6.了解你的工具：调试工具是用来观察系统的眼和耳，你必须选择正确的调试工具，正确的使用工具，并正确的解释得到的结果。还要必须了解工具的局限性，可以显示什么错误，不能显示什么错误。还必须了解开发工具，所使用的编程语言；
7.在项目中，对一个组件或者语法的运用有分歧，不要盲目的相信自己的记忆力，不要猜测，去查阅手册，要养成良好的查阅习惯。
制造失败 有时候理解了系统，还是锁定不了 Bug 的来源，这时候就需要执行下一个方案了。
1.制造失败：顾名思义就是把失败再重复一遍，或者几遍。
为什么要制作失败呢？">
<meta name="twitter:description" content="Debuging 调试在编程工作中很常见，几乎每天都会很它打交道。可以说对于编程人员来说是一件很困扰的事情，有时候查找一个 Bug 原因，需要花费大量的时间和精力。
本书一共总结了调试规则九则：
1.理解系统
2.制造失败
3.不要想，而要看
4.分而治之
5.一次只改一个地方
6.保持审计跟踪
7.检查插头
8.获得全新观点
9.如果你不修复 Bug，它将依然存在
单看这 9 个规则的标题，会有熟悉的感觉吧，会不会跟自己平时调试的时候，有一些方法差不多，觉得很简单。那回想一下，这些简单的规则，是否都能用对地方呢，是否在关键的时候，想的到呢？
其实在实际工作中，有时候越简单的规则往往越被人忽略。有些规则显而易见，会记得运用在特定的问题上，越往往不容易；有时候会被人忽视，有时候会走所谓的捷径，最终所花的时间越久。所以看的过程中，有时候会产生共鸣；有时候会暗自懊悔，自己为什么当时没有使用这种调试方法，所以要记住并运用好这些规则会很有帮助。
读这本书并写下读书笔记，最主要的是想提高自己的调试能力，提高工作效率；当然也能节省下来时间去做其他的事情。 书中每个规则里面都有详细细分了规则使用的不同情况，还有举例说明。我把自己在看书过程中的想法记录一下，加深下对于规则的理解，以便更好的运用到工作生活中去。
理解系统 项目已经到了中后期，基本每天会被分配到不同的 Bug，有时候会接到自己不熟悉的功能 Bug，接到这样的 Bug，首先要做的工作就是理解系统。
理解系统就是你必须掌握系统的工作原理以及它是如何设计的，在某些情况下，还要知道为什么这么设计，如果你没有理解系统的某个部分，那么通常就是出问题的地方。
『昨天我在查找一个 Bug 的原因：我查找到在跟 AI 一起比赛时，对方使用的 Buff 跟显示出来的一致；跟真实的玩家比赛时，对方使用的 Buff 跟显示出来的不一致。我咨询了主程 AI 跟真实玩家的数据上的区别：AI 的 Buff 使用是纯客户端处理，而真实的玩家需要发送给服务端，服务端会再进行计算，再分发给其他玩家的。我断定问题出在服务器那边。最后结果肯定不是服务端的问题，问题出在客户端读取服务端的一个类型 type 上，type 并不是 BuffType 而是需要做一个类型转换，之前直接当做 BuffType 接收的，所以会出现对方使用跟显示不一致的问题。』
上面的事例中我忽略了一个错误，就是没有理解系统，我没有去查看这个功能的数据接口相关的文档说明，导致了判断错误。
在开发的过程中，在接触到新的功能时、修改 Bug，容易犯经验主义错误，没有仔细的看相关文档，导致最后漏掉功能细节，或者修改 Bug 不彻底，甚至找不到出现 Bug 原因。
理解系统可以通过以下几方面来做：
1.阅读手册，手册里会告诉你正确的使用方法；
2.逐字逐句的阅读整个手册，解决问题的方法可能就隐藏在不起眼的角落；
3.知道什么是正常的，即必须掌握你所工作技术领悟内的基础知识，才能知道什么是正常的；
4.知道工作流程：当你尝试查找错误时，必须知道要查找的路线；
5.调试工具是用来观察系统的眼和耳，你必须选择正确的工具，正确地使用工具，并正确地解释得到的结果；你越是精通工具，就越容易查明系统中发生了什么事情；
6.了解你的工具：调试工具是用来观察系统的眼和耳，你必须选择正确的调试工具，正确的使用工具，并正确的解释得到的结果。还要必须了解工具的局限性，可以显示什么错误，不能显示什么错误。还必须了解开发工具，所使用的编程语言；
7.在项目中，对一个组件或者语法的运用有分歧，不要盲目的相信自己的记忆力，不要猜测，去查阅手册，要养成良好的查阅习惯。
制造失败 有时候理解了系统，还是锁定不了 Bug 的来源，这时候就需要执行下一个方案了。
1.制造失败：顾名思义就是把失败再重复一遍，或者几遍。
为什么要制作失败呢？">
<meta property="og:locale" content="en">

  
    <meta property="article:published_time" content="2018-05-28T22:35:26">
  
  
    <meta property="article:modified_time" content="2018-05-28T22:35:26">
  
  
  
  


<meta name="twitter:card" content="summary">












    <title>调试九法</title>

    <link rel="icon" href="/favicon.png">
    

    

    <link rel="canonical" href="https://yuyaoxue.github.io/post/2018-05-27-debuging/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="/css/style-nnm2spxvve8onlujjlegkkytaehyadd4ksxc1hyzzq9a2wvtrgbljqyulomn.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="/">薛玉瑶的博客</a>
  </div>
  
</header>

      <nav id="sidebar" data-behavior="">
  <div class="sidebar-container">
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/about/">
    
      <i class='fa fa-heart'></i>
      
      <span class="sidebar-button-desc">about hugo</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior=""
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      调试九法
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2018-05-28T22:35:26&#43;08:00">
        
  
  
  
  
    28  2018
  

      </time>
    
    
  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              

<h1 id="debuging">Debuging</h1>

<p>调试在编程工作中很常见，几乎每天都会很它打交道。可以说对于编程人员来说是一件很困扰的事情，有时候查找一个 Bug 原因，需要花费大量的时间和精力。</p>

<p>本书一共总结了调试规则九则：</p>

<p>1.理解系统</p>

<p>2.制造失败</p>

<p>3.不要想，而要看</p>

<p>4.分而治之</p>

<p>5.一次只改一个地方</p>

<p>6.保持审计跟踪</p>

<p>7.检查插头</p>

<p>8.获得全新观点</p>

<p>9.如果你不修复 Bug，它将依然存在</p>

<p>单看这 9 个规则的标题，会有熟悉的感觉吧，会不会跟自己平时调试的时候，有一些方法差不多，觉得很简单。那回想一下，这些简单的规则，是否都能用对地方呢，是否在关键的时候，想的到呢？</p>

<p>其实在实际工作中，有时候越简单的规则往往越被人忽略。有些规则显而易见，会记得运用在特定的问题上，越往往不容易；有时候会被人忽视，有时候会走所谓的捷径，最终所花的时间越久。所以看的过程中，有时候会产生共鸣；有时候会暗自懊悔，自己为什么当时没有使用这种调试方法，所以要记住并运用好这些规则会很有帮助。</p>

<p>读这本书并写下读书笔记，最主要的是想提高自己的调试能力，提高工作效率；当然也能节省下来时间去做其他的事情。
书中每个规则里面都有详细细分了规则使用的不同情况，还有举例说明。我把自己在看书过程中的想法记录一下，加深下对于规则的理解，以便更好的运用到工作生活中去。</p>

<h2 id="理解系统">理解系统</h2>

<p>项目已经到了中后期，基本每天会被分配到不同的 Bug，有时候会接到自己不熟悉的功能 Bug，接到这样的 Bug，首先要做的工作就是理解系统。</p>

<p>理解系统就是你必须掌握系统的工作原理以及它是如何设计的，在某些情况下，还要知道为什么这么设计，如果你没有理解系统的某个部分，那么通常就是出问题的地方。</p>

<p>『昨天我在查找一个 Bug 的原因：我查找到在跟 AI 一起比赛时，对方使用的 Buff 跟显示出来的一致；跟真实的玩家比赛时，对方使用的 Buff 跟显示出来的不一致。我咨询了主程 AI 跟真实玩家的数据上的区别：AI 的 Buff 使用是纯客户端处理，而真实的玩家需要发送给服务端，服务端会再进行计算，再分发给其他玩家的。我断定问题出在服务器那边。最后结果肯定不是服务端的问题，问题出在客户端读取服务端的一个类型 type 上，type 并不是 BuffType 而是需要做一个类型转换，之前直接当做 BuffType 接收的，所以会出现对方使用跟显示不一致的问题。』</p>

<p>上面的事例中我忽略了一个错误，就是没有理解系统，我没有去查看这个功能的数据接口相关的文档说明，导致了判断错误。</p>

<p>在开发的过程中，在接触到新的功能时、修改 Bug，容易犯经验主义错误，没有仔细的看相关文档，导致最后漏掉功能细节，或者修改 Bug 不彻底，甚至找不到出现 Bug 原因。</p>

<p>理解系统可以通过以下几方面来做：</p>

<p>1.阅读手册，手册里会告诉你正确的使用方法；</p>

<p>2.逐字逐句的阅读整个手册，解决问题的方法可能就隐藏在不起眼的角落；</p>

<p>3.知道什么是正常的，即必须掌握你所工作技术领悟内的基础知识，才能知道什么是正常的；</p>

<p>4.知道工作流程：当你尝试查找错误时，必须知道要查找的路线；</p>

<p>5.调试工具是用来观察系统的眼和耳，你必须选择正确的工具，正确地使用工具，并正确地解释得到的结果；你越是精通工具，就越容易查明系统中发生了什么事情；</p>

<p>6.了解你的工具：调试工具是用来观察系统的眼和耳，你必须选择正确的调试工具，正确的使用工具，并正确的解释得到的结果。还要必须了解工具的局限性，可以显示什么错误，不能显示什么错误。还必须了解开发工具，所使用的编程语言；</p>

<p>7.在项目中，对一个组件或者语法的运用有分歧，不要盲目的相信自己的记忆力，不要猜测，去查阅手册，要养成良好的查阅习惯。</p>

<h2 id="制造失败">制造失败</h2>

<p>有时候理解了系统，还是锁定不了 Bug 的来源，这时候就需要执行下一个方案了。</p>

<p>1.制造失败：顾名思义就是把失败再重复一遍，或者几遍。</p>

<p>为什么要制作失败呢？</p>

<p>制造失败的原因有三个：可以观察他、可以专心的查找问题的原因、可以判断是否已修复问题。</p>

<p>2.要如何制造失败呢？</p>

<p>不同的情况采取的方式也不同。</p>

<p>最好的是在相同的环境下再操作一次。仔细观察做了什么，然后再做一遍，记录每一个操作步骤，然后按着步骤去做，看看是否能复现问题；如果复现的步骤简单，那就从头开始操作；如果复现的步骤复杂，且复现的频率不一定，这时候可以添加自动化测试。</p>

<p>3.不要尝试模拟失败</p>

<p>引发失败和模拟失败是不一样的。引发失败是在相同的办完操作环境下，试图重现失败的过程，即使做了一些改变，也是影响错误发生的频率，并没有影响错误发生的方式；而模拟错误是猜测错误发生的方式，并构建一个配置来模拟，这个有可能会发现新的问题。</p>

<p>4.间歇性 Bug</p>

<blockquote>
<p>当故障只是偶尔发生时，用『制造失败』这种方法来调试就困难得多。很多棘手的问题都是间歇性的，这就是不能总是应用这条规则的原因—— 它很难应用。</p>
</blockquote>

<p>那么如何处理间歇性 Bug 呢？</p>

<blockquote>
<p>首先，把可能影响结果的因素都整理一下，然后查明它们；一旦查到了有哪些条件可能影响你的系统，必须大量尝试与这些条件相符的各种形式；初始化这些条件，并按照一种已知模式把这些条件作为你的问题软件的输入。</p>
</blockquote>

<p>5.如果做了所有尝试之后问题仍然间接性发生</p>

<p>那么就要回归制造失败的最初的目的：一是观察错误，二是查找线索，三是确认是否已修复。</p>

<p>如何确认是否已修复呢？</p>

<blockquote>
<p>更好的方法是找到一个总是与失败有关的事件序列。即使这个序列本身就是间接性的，但当它发生时，100% 会发生失败；然后当你确实已修复 Bug 时，就可以运行测试，直到这个序列出现如果没有发生失败，那么你确实已修复了 Bug。</p>
</blockquote>

<p>6.那不可能发生</p>

<p>『那不可能发生』这句话之前我自己也跟其他同事说过，但结果往往是打脸的。既然同事测试出来了一些问题，事实是 Bug 已经出来了，我们只有接受这个数据并仔细分析具体情况，才会发现那个问题，然后尽快解决那个 Bug。</p>

<p>7.永远不要丢掉一个调试工具</p>

<blockquote>
<p>有时候调试工具可以在其他的调试场合重复使用。当你设计它的时候，应该考虑到这一点，并且使它易于维护和升级，有时候也可以靠这个赚钱。</p>
</blockquote>

<h2 id="不要想-而要看">不要想，而要看</h2>

<blockquote>
<p>在没有事实作为参考以前妄下结论是个很大的错误，主观臆断的人总是为了套用理论而扭曲事实，而不会用理论来解释事实。</p>
</blockquote>

<p>当要去解决一个 Bug 时，在前期亲眼看到 底层的失败是非常重要的。不要猜测失败是如何发生的，尝尝会修复一些不是 Bug 的问题；不但解决不了问题，还会浪费时间和金钱。</p>

<p>『不要想，而要看』中的『看』可以通过以下几方面来看</p>

<p>1.观察失败</p>

<p>2.查看细节</p>

<p>3.植入插装工具</p>

<p>4.添加外部插装工具</p>

<p>5.不要害怕深入研究</p>

<p>6.注意海森堡效应</p>

<p>7.猜测只是为了确定搜索的重点</p>

<h2 id="分而治之">分而治之</h2>

<blockquote>
<p>当你排除了所有的不可能，不管留下了什么，也不管看起来多么不可思议，那必定都是事实。</p>
</blockquote>

<p>『分而治之』通俗的说，就是排除法，把最不可能的排除掉，剩下的就是有可能的；再在有可能的当中，排除掉最不可能的，剩下的一个，就是要找的 Bug 或者答案。</p>

<p>书中将『分而治之』分为 6 部分来介绍</p>

<p>1.缩小搜索范围</p>

<p>确定范围；确定问题在那一侧。</p>

<p>2.插入易于识别的模式</p>

<p>3.从有问题的支路开始查找问题</p>

<p>4.修复已知 Bug，Bug 互相保护，互相隐藏。因此一旦找到，立即修复它们。</p>

<p>5.首先消除噪声干扰</p>

<p>注意那些导致系统问题的干扰因素。对一些跟这个 Bug 无关的问题先记录下来，不要在这个  Bug 的过程中发现了另一个 Bug，又去解决另一个 Bug 去了。</p>

<h2 id="一次只改一个地方">一次只改一个地方</h2>

<p>在尝试修复 Bug 的过程中，一次只改一个地方；要观察到具体发生了什么问题，再来尝试修复；修复的过程中，要隔离关键因素，一次只改一个测试；并与正常情况进行比较，如果所有出错的情况都有一些特征，而这些特征是正常情况下所没有的，那么就找到了问题所在；还要确定一下自从上一次正常工作以来你改变了什么地方，这有可能是问题的关键。</p>

<h2 id="保持审计跟踪">保持审计跟踪</h2>

<blockquote>
<p>保持审计跟踪，在检查某问题时，要记下来你所做的事，做事的顺序，以及发生的结果。每次都要完成这些记录。你是在检测测试步骤，就像检测软硬件一样。必须清楚没一个步骤和每步执行的结果，以此确定在调试时应重点关注哪一步。</p>
</blockquote>

<p>我们在项目中的所使用的的 Log 日志，也属于审计跟踪。日志里面包括一些详细操作、操作的时间、相关数据。通过日志会发现这个问题的严重程度。对比不同的日志能发现 某些 症状与 其他症状 之间的一些『关联』，从而有可能发现出现 Bug 的原因。</p>

<p>写到这里想到了项目中用到了项目配置控制工具对于测试 Bug 也是很有帮助的。它可以告诉你那次修订引入了 Bug；能帮你『确定一下自从上一次正常工作以来你改变了什么地方』。</p>

<p>俗话说『好记性不如烂笔头』，在某些时候不要相信你的记忆，而要把它写下来。</p>

<h2 id="检查插头">检查插头</h2>

<p>有时候遇到问题或者发现 Bug ，是一些简单的问题造成的。
一些显而易见的假设往往是错误的，但有时候是最容易修复的错误。</p>

<p>1.怀疑自己的假设
2.从头开始检查
3.对工具进行测试</p>

<h2 id="获得全新观点">获得全新观点</h2>

<blockquote>
<p>想要重新沥青一个案子的头绪，最好的方法就是把它将给别人听。</p>
</blockquote>

<p>当自己身在一个 Bug 的迷雾中的时候，那个时候已经没有什么头绪了。这个时候需要跟其他人沟通下，可能会柳暗花明。</p>

<p>1.征求别人的意见，可能会帮助自己认识到先前没有注意到的事情。</p>

<p>2.获得专业知识，能够知道确定具体什么功能发生了错误。</p>

<p>3.听取别人的经验，别人可能比你经验多，也可能之前遇到过类似的问题。</p>

<p>4.帮助无处不在。</p>

<p>5.放下面子，Bug 发生了，以除掉 Bug 为自豪，而不要非得以自己除掉 Bug 才自豪。</p>

<p>6.报告症状，而不要讲你的理论，这样容易把别人拖进你的思维定式中。</p>

<p>7.你提出的问题不必十分肯定，自己有怀疑的事情可以提出来，有可能是问题的关键。</p>

<h2 id="如果你不修复-bug-它将依然存在">如果你不修复 Bug，它将依然存在</h2>

<blockquote>
<p>当危险已经离你很近时，拒绝承认它并不是勇敢的表现，而是愚蠢。</p>
</blockquote>

<p>Bug 没有自己的思维，从来不会自动修复，虽然我们都希望看到 Bug 消失。如果自己修复了一个 Bug 后，要去立即检查问题是否已被修复，不要假设问题已被修复，而要测试它；检查确实是修复措施解决了问题，即取消这个修复，确定系统再次失败，然后再应用这个修复，再次验证问题已修复；如果这个 Bug 实在不好修复，也不要忽略它，要记录下来；要从根本上解决问题，而不是短暂的修复，那样过一段时间，还会 Bug 还会出现；要对过程进行修复，不要只是擦掉地上的油，而要纠正设计机器的方式。</p>

<p>笔记中大多数都有引用的书中的文字，是因为我感觉作者已经用了很准确是词句去描述，自己找不到更合适的词语去替代。</p>

<p>调试规则笔记写好了，接下来就是在项目中运用实际运用了，谨记关键的 9 条规则。</p>

              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="/post/2018-05-29-githubcustomdomain/" data-tooltip="GitHub 自定义域名">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml"></span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="/post/2018-05-23-supertextmesh/" data-tooltip="图文混排总结">
              
                  <span class="hide-xs hide-sm text-small icon-mr"></span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2018 薛玉瑶的博客. 
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="/post/2018-05-29-githubcustomdomain/" data-tooltip="GitHub 自定义域名">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml"></span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="/post/2018-05-23-supertextmesh/" data-tooltip="图文混排总结">
              
                  <span class="hide-xs hide-sm text-small icon-mr"></span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
    <h4 id="about-card-name"></h4>
    
    
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center"></div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://yuyaoxue.github.io/post/2018-09-20-class_modifier/">
                <h3 class="media-heading">C# 中的访问修饰符和声明修饰符</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">前言 C# 中的访问修饰符和声明修饰符挺多的，总结一下，做个记录。
访问修饰符 访问修饰符通常作为声明字段数据类型的前缀，它标识了所修饰成员的封装级别。可以选择 5 个访问修饰符，即 public、private、protected、internal和 protected internal。
public 公有的：显式指明可从类的外部访问被它修饰的字段。
private 私有的：只有在声明它们的类和结构中才可以访问。如果不为类成员添加修饰符，那么默认使用的是 private。成员默认为私有成员，公共成员必须显式指定。
protected 受保护的：可在基类中定义只有派生类才能访问的成员。
internal 内部的，同一个程序集中的所有类都可以访问。
protected internal 访问级别为 internal 或 protected。即，“同一个程序集中的所有类，以及所有程序集中的子类都可以访问。
声明修饰符 目前了解的声明修饰符有 8 个，即 partial、static、abstract、Sealed、Virtual、Override、New、Extern。
Partial 在整个同一程序集中定义分部类和结构。
Static 声明属于类型本身而不是属于特定对象的成员。
Abstract 抽象类不可实例化，只能是其他类的基类。类中的方法只声明不实现，方法的实现在他的派生类中完成。其作用是强制所有派生类提供实现。
Sealed 对类使用 sealed 修饰符可以禁止从该类继承。
Virtual 用于修饰方法、属性、索引器或事件声明，并且允许在派生类中重写这些对象。
规则：虚方法只提供默认实现，这种实现可由派生类完全重写；“运行时”遇到虚方法时，他会调用虚成员派生得最远的，重写的实现。
Override 提供从基类继承的成员的新实现。
New 作为修饰符，在基类面前隐藏了派生类重新声明的成员，在不使用 new 修饰符的情况下隐藏成员是允许的，但会生成警告。作为运算符，用于创建对象和调用构造函数。
Extern 用于声明在外部实现的方法。 extern 修饰符的常见用法是在使用 Interop 服务调入非托管代码时与 DllImport 特性一起使用。 在这种情况下，还必须将方法声明为 static。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://yuyaoxue.github.io/post/2018-09-09-coroutine/">
                <h3 class="media-heading">浅谈协程</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">前言 在 Unity 中，对协程的使用度非常高；面试的时候，也多数会被问到。自己都没有系统的整理下协程相关的知识。借此机会，梳理下自己对协程理解，以便更好的理解协程。
什么是协程？ 协程（Coroutines）通过字面意思是协助程序。
 A coroutine is like a function that has the ability to pause execution and return control to Unity but then to continue where it left off on the following frame。  这是 Unity 官网文档 中对协程的解释.
协程的原理 协程是一个部分执行，遇到条件（yield return）会挂起，知道条件满足才会被唤醒继续执行后面代码的一种函数。 Unity 在每一帧（Frame）都会去处理对象上的协程。Unity 主要是在 Update 后去处理协程（检查协程的条件是否满足）  Coroutines 不是多线程，不是异步技术，协程都在 MainThread 中执行，而且每个时刻只有一个 Coroutine 在执行。 Coroutine 是一个 function，可以部分执行，当条件满足时，未来会被再次执行直到整个函数执行完毕。
协程在 unity 脚本执行顺序的位置 测试 根据协程的原理和协程在 Unity momo 脚本执行顺序做一个小测试来验证其原理。
public class Test : MonoBehaviour { void Start () { Debug.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://yuyaoxue.github.io/post/2018-08-12-selfreflectionatwork/">
                <h3 class="media-heading">工作自我反省</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Aug 8, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">前言 前段时间看了一本有关程序员的职业素养的书《代码整洁之道 程序员的职业素养》。在这本书里，作者重新定义了专业程序员，要想成为真正专业的程序员，需要什么样的态度、原则、行动；这些态度、原则、行动都源于作者一路走来的亲身体会。可以把这本书当成一份指引，靠它绕开一些弯路，提高自己的职业素养。
本来想要总结程序员的职业素养，作者写的观点简洁明了，苦思良久，实在总结不出啥了。索性总结一下我这段时间工作上的犯过的错误以自省。
打包 面对自己不知道怎么办的时候，想别人请教。
对于打包这件事，面对自己不知道怎么打包，想当然的试着打一下包。殊不知，自己在公共打包环境，试着打包，有可能会对其他人测试环境，造成多大的影响。从而增加修复的工作量。在工作中，要保持严谨的工作态度，不能儿戏。明确自己工作中的每次操作，尤其是跟他人合作，或者在公共的环境下。自己做的每一步操作，都要清楚自己在做什么；
分支合并时，时刻保持清醒 保持清醒，清楚自己的每一步操作，在关键时刻尤为重要。
到项目的后期之后，不同分支（提审分支，稳定分支）在分支合并的时候，一定要清楚该做什么，不该做什么；一定要清楚自己哪些提交是需要cherry-pick 到稳定分支。
ps：（项目规定 merge 操作是单方向的，即：在 master 分支 merge 过 feature 分支之后，就不能再在该 feature 分支 merge master 分支）。
做任何操作都要清楚自己在做什么 在操作命令行的时候，首先明确自己的需求，再者要清楚每一步操作意义；不能抱着试试的想法，有一些操作可能是不可逆的，而自己不清楚，从而会造成不可预知的错误。
对自己的工作负责 接到新任务后，无论是不是新的一项任务，还是功能优化，都要对这项任务进行全面的了解：策划文档，与负责人沟通并确认需求，任务需要的测试环境，测试周期等等。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://yuyaoxue.github.io/post/2018-08-05-aboutprefab/">
                <h3 class="media-heading">有关于 .prefab 与自身挂载组件的关系</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Aug 8, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">问题 在 UI Panel 添加了一个粒子特效，打开该 Panel 时，特效不显示，选中特效时，特效又会显示出来。
测试 同事提醒可能跟特效的父级的 Scale 有关系。经过测试，确实跟 Canvas 的 Scale 有关系。因为我们项目 UI 框架设计的原因，将 UIPanel 制作成 prefab 时，将 UIPanel 的 Active 设置为 false；在 UIPanel 在加载成功时，Canvas 的 Scale 为 0，设置 UIPanel.SetActive(true) 之后，Canvas 的 Scale 为 1。
测试 Canvas 的 Scale 为 0 的原因 经过测试，Canvas 的 Scale 为 0 的原因跟 Canvas 的 Render Mode 有关系：
Canvas 的 Render Mode 设置不同，对于 RectTransform 组件上的值是有影响的。
当 Renderer Mode 为 Screen Space - Camera 或 Screen Space -Overlay 时 Canvas 的 Scale 会为 0 ，如果为 World Space 时，Scale 就会变为 1。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://yuyaoxue.github.io/post/2018-07-30-how-to-ask-questions-the-smart-way-note/">
                <h3 class="media-heading">提问的智慧-阅读笔记</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">前言 向其他人提问问题是很常见的事情，尤其从事计算机方面的工作，所以拥有提问的智慧尤为重要。提问的智慧这篇文章里面的提问环境是在技术论坛上或者邮件的形式。看完这篇文章之后，结合着自身的情况，写一些总结。
提问之前 1.在工作中遇到项目功能设计上的疑问，先去翻阅相关策划方案；如果还有疑问，把问题总结好再去跟相关人员提疑问。
2.如果遇到技术上的问题；
首先，尝试自己解决问题：
1-&gt;自己检查或者试验找到答案；
2-&gt;去查阅相关文档或者 API；
3-&gt;尝试上网搜索以找到答案；
4-&gt; 尝试阅读源代码以找到答案；
如果做了上述的努力，还是没有找到合适的解决方案，就需要想身边的高手提问题。
提问题时 给别人描述问题的时候，使用清晰，正确，精准并语法正确的语句；也就是仔细，清楚地描述你的问题或 Bug 的症状。不要说一堆话，没有重点，既没有把问题描述清楚，也浪费了别人的时间。
未完待续 &hellip;</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://yuyaoxue.github.io/post/2018-07-29-incorrectuseofgitrebase/">
                <h3 class="media-heading">有关 git rebase 错误使用引发的问题</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">前言 本文是前几天我在工作中使用 git 指令合并分支的时候出现了问题，而当时采取了直接 “跳过问题” 的解决方案，导致了文件显示不出来了。所以写一份报告总结记录下。
错误 在 master 分支上跟其他分支进行 merge 时，二进制文件出现冲突。后续使用解决冲突的方式不对，导致二进制文件（.png 图片）显示不出来。
表面原因 出现错误的原因是：在出现冲突时，我先错误的使用了 “他人分支”，出现错误 “无法更新一个或多个文件，请确保没有其他的应用正在锁定你的文件” 时，后使用 “标记为已解决”。后来冲突文件消失了，我当时以为问题真的被解决了。
根本原因 在我的分支上跟 master merge 过，后来提交过几次之后，又进行了 rebase 操作重写历史提交信息后没有成功修改我的提交信息，后来我又通过 &ndash;soft 操作把我分支上的所有的提交都 reset 了，最后合并成一个提交。
执行 rebase 之后，跟 master merge 之后的文件的提交信息都丢失了，而这些文件在 master 分支上又被其他人修改过。导致我在回到 master 分支之后再跟我的分支 merge ，那些丢失提交信息的文件，就会出现冲突。
rebase 会将合并提交变为普通提交，丢失父节点信息。  使用 “他人分支” 或使用 “我的分支” 解决冲突失败是因为找不到文件的版本号
 $ git checkout --theirs /e/Unity_new/client/Assets/Textures/Sprites/Quality/Content/CarQuality_D.png error: path 'Assets/Textures/Sprites/Quality/Content/CarQuality_D.png' does not have their version  思考 对于这一问题的处理方式，我犯了几个错误：
1.对于解决冲突的方式：“他人解决”，“我的解决”，“标记为已解决”，这几个操作所表示的意义不够深刻，导致做出了错误的操作。
2.在 master 分支上进行分支 merge 时候，出现冲突文件错误信息，没有仔细分析。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://yuyaoxue.github.io/post/2018-07-25-gameprogrammingnote/">
                <h3 class="media-heading">《游戏编程算法与技巧》读书笔记一</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">前言 前段时间阅读了一本有关游戏编程的书《游戏编程算法与技巧》，书中介绍了大量今天在游戏行业中用到的算法与技术。包括 2D 和 3D 图形学、物理、人工智能、摄像机等多个方面的技术。
知识框架图 这本书的读书笔记，我打算分成几部分，第一次我按着书上的不同的章节，简单的画了一个框架图，看着比较直观，细节上的内容在后续的博客里加上。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://yuyaoxue.github.io/post/2018-07-15-supertextmeshmemoryuninstall/">
                <h3 class="media-heading">SuperTextMesh MemoryUninstall Bug</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">前言 前一段时间将 SuperTextMesh 导入到项目中，实现图文混排。最近使用 SuperTextMesh 来实现炫酷的文字特效。在使用过程中，发现了 SuperTextMesh 内存卸载的 Bug。从查找问题到解决断断续续花了有一周的时间，现在问题解决了，写一个总结记录下。
问题描述 项目中，在游戏界面上有使用 SuperTextMesh 来实现文字特效，在网络断开的时候文字会突然消失。经过调试，发现了网络断开的时候，代码在调用了 Resources.UnloadUnusedAssets() ，之后 SuperTextMesh 的文字就消失了。测试将那行代码注释掉，文字就不消失了。于是就沿着这个方向开始查找。
问题复现 为了验证 Bug 确实是资源卸载引起的，重新创建了一个全新的项目，将插件导入空项目中。
运行环境 SuperTextMesh：1.7.1
OS：Windows 10，64 位操作系统，基于 x64 的处理器
Unity：Unity 2017.4.2f2 (64-bit)
Visual Studio：2017
复现操作 在场景中，创建 SuperTextMesh，Button；给 Button 添加点击事件，事件里调用 Resources.UnloadUnusedAssets()。开始运行，文字显示；点击按钮 Button， 文字消失。
找出原因 猜想一 当时还未锁定是资源卸载的问题的时候，排查方向是文字的参数发生了变化。
之前美术同事在做特效的时候，也出现过类似的问题，也会消失；然后选中该特效又能显示出来。后来找出的问题是：在过程中，有父集的 Scale 为 0 导致没有显示。所不同的是，我的一开始是显示的，只是后面消失了。
我根据同事的解决办法去检测下，SuperTextMesh 消失后他的 Scale 的情况，一并检测了其他会影响消失的参数，都没有找到问题所在，所以排除这个猜想。
之后的猜想都是关于资源卸载后，将使用中的 Text 里面的资源卸载掉的原因。
猜想二 Resources.UnloadUnusedAssets()；会卸载掉不被引用的 assets，查代码找到 SuperTextmMeshData 的一个引用是通过 Resources.Load() 加载资源赋值的，后来看到 data 是一个私有静态成员变量，Resources.UnloadUnusedAssets() 不可能会卸载掉他（静态成员变量的引用一直会在）。
猜想三 问题出现的时候，在 FrameDebug 中 UGUI.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://yuyaoxue.github.io/post/2018-07-08-unitycompilationbug/">
                <h3 class="media-heading">Unity Compilation Bug</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">前言 前几天在工作中，遇到一个有关 Unity 编译失效的问题，我修改的脚本保存后，Unity 自动编译后，编译失效。
问题描述 我在 VS 里修改了代码保存之后，回到 Unity 里，Unity 自动编译，编译完成之后，还是我修改代码之前的情况（我修改的文件没有被编译）。
问题复现 比如：我修改并了脚本 A，回到 Unity，Unity 自动编译，在编译期间修改并保存了脚本 B。编译完成之后，脚本 B 修改的部分极有可能没有被编译。
找出原因 1.检查了 Unity 的自动编译开关 Edit-&gt;Unity Preferences-&gt;General-&gt;Auto Refresh; 排查了 Unity 的设置问题 2.后来问了同事之后才了解的，这个问题 Unity 标记最后编译时间机制有关系。对于 Unity 而言，VS 只是一个编辑脚本工具，所有的编译工作都在 Unity 这边执行。Unity 不会记每个文件的编译时间，只会记录一个总的最后的编译时间。比如 Unity 编译开始时间为 t1 编译过程需要 10s，最后的编译时间为 t1+10s，如果在这 10s 内又对脚本做了修改，恰好这个脚本已经被编译过了。那这个脚本不会重新被编译，导致了后面的那次修改没有被编译。
解决办法 如果发生了编译失效问题，可以试试以下方法解决：
1.修改并保存编译失效脚本；
2.关闭并重新打开 Unity，重新修改并保存编译失效脚本。
总结与思考 有两点疑问没有解决： 1.Unity 最后编译时间存储在什么地方？ 2.各个文件的编译时间存储在什么地方？
后续查 Unity 标记编译时间相关的资料没查到。听同事说这是 Unity 编译的一个 Bug，个人解决不了，只能在做的过程中尽量避免。现在我都会尽量避免在 Unity 执行编译的时候修改脚本。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://yuyaoxue.github.io/post/2018-07-01-firstpublicflappybird/">
                <h3 class="media-heading">First Publish FlapyBird</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">前言 这是我在 GitHub 上发布的第一个游戏作品。确切地说，不能算是一个作品，只能是一个小 Demo。项目中所实现的功能效果，离原版差太多。这也让我明白，要做出好的东西，是需要花费很多精力去做的。
游戏介绍 在《FlappyBird》这款游戏中，玩家只需要用一根手指来操控，点击触摸屏幕，小鸟就会往上飞，不断的点击就会不断的往高处飞。放松手指，则会快速下降。所以玩家要控制小鸟一直向前飞行，然后注意躲避途中高低不平的管子。
项目工程
项目已发布到GitHub Releases：项目地址
制作目的 制作游戏的目的在于锻炼独立做项目的能力。由于工作的安排，有时候自己接触到的功能模块比较单一，这就导致自己涉足的其他方面的机会比较少，所以在工作之余写一些简单的 Demo，FlappyBird 是我前一段时间写的一款 Demo。
流程框架 涉及到知识点总结 遇到的难点 功能难点：
1.最核心的是小鸟的飞行和下落的功能，飞行的不自然，缺少上升下落的角度；
2.使用 JSON 实现本地数据保存和读取来实现排行榜;
3.资源动态管理;
4.png 图片的动态切割
设计难点:
1.游戏框架，目前采用 Manager Of Managers;
2.游戏状态，使用有限状态机管理游戏状态，还未写好。
总结与思考 从项目开始到今天，有三周的时间（工作之外的时间），真正用到项目中总的时间大概就三四天的时间吧，这个项目的也不大，整体难度也不难，做起来感觉很费时间，实现一个小功能，花时间比较多，而且返工的次数很多。
这个项目做下来，自己身上已知的好多问题突显出来了。比如知识的缺乏，缺乏自制力，严重拖延症等。想的太多，做的太少，可能是我最大的问题了。
我接下来要做的是上面列出的难点。之后会不断的完善缺少的功能，不定期的更新 FlappyBird 的项目进度。
反思和记录下来自己问题，努力下一个游戏，项目的完成度和质量高一些。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero=""
         data-message-one=""
         data-message-other="">
         21 posts found
      </p>
    </div>
  </div>
</div>
    

    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="/js/script-qi9wbxp2ya2j6p7wx1i6tgavftewndznf4v0hy2gvivk1rxgc3lm7njqb6bz.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>


  
    
  




    
  </body>
</html>

