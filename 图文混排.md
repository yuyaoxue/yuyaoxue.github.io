# 图文混排
   最近在做图文混排相关的功能，先后使用了几种方式实现；有的本身有问题，有的不适用与我们的项目， 总结一下以后略过这些坑。
## 第一种：项目里的TextWithImage (搁置)
   Text中加载个Image是没有问题，加载1个以上，就会报错(错误位置是TextWithImage里99行)，将多余的Image的enable设置为false，不能进行设置，<br>删除等操作，还会出现加载一个Image 创建出2个， 加载2个，创建出3个…..翻倍的创建Image，消耗性能。
## 第二种是：TextInlineSprite(text中插入图片) (搁置)
   1：总体显示方面都还ok(可以设置image显示大小,支持动态图）<br>
   2：显示bug（表情会出现丢失的情况，关掉界面再打开就会显示）<br>
   3: 需要手动清理画布上的表情list显示(如果是分页显示的话，切换表情时，需要把前一个Image内同清理掉)<br>
   4:最严重的问题时分辨率适配问题(不同比例的分辨率，表情位置会出现偏差，目前没有找到合适的办法解决),<br>
   在网上看的是， 写插件的作者之前设计的时候，没有把适配考虑进去，<br>
   5:性能未测试<br>
参考链接：<br>
[TextInlineSprite](https://blog.csdn.net/qq992817263/article/details/51000744)<br>
 
## 第三种是 EmojiText(文字和图片独立渲染) (搁置)
  这个方案目前想到有两个弊端：<br>
  1：Outline、Shadow使用时，图片也被处理的问题<br>
  2：图片是根据文字大小来渲染的，跟文字大小一样，显示看起来表情没有很突出<br>
参考链接：<br>
[EmojiText(文字和图片独立渲染)](https://blog.uwa4d.com/archives/Sparkle_UGUI.html)<br>
 上面的这些情况是我在项目中遇到的实际问题，以下链接中有详细的<br>
[UGUI 图文混排解决方案和优化](http://www.cnblogs.com/zsb517/p/6667050.html)<br>


## 第四种：Super Text Mesh (采用)
SuperTextMesh是个功能很强大的插件，可以实现渲染动态文字，富文本支持图文混排。具体的功能类型有：文字效果，<br>TextColor,Automatic,Master,Inline;(图文混排就是Inline的一种实现方式：Quads.)<br>
还有一个比较好的是，SuperTextMesh是开源的，根据项目的需求可以修改源代码。<br>
unityAssetStore下载链接<br>
[Super Text Mesh](https://assetstore.unity.com/packages/tools/gui/super-text-mesh-57995)<br>
**1.导入SuperTextMesh1.7.1**<br>
新建一个unity项目，然后双击Super Text Mesh.unitypackage导入 如图1.1<br>
  ![图1.1](_v_images/_图11_1525967278_19536.png)
                 图1.1<br>
  
导入项目之后，接下来说下SuperTextMesh的使用流程。<br>
**2: 添加Super Text Mesh 到 Scene**<br>
      1->创建UI Super Text Mesh 如图2.1<br>
 ![图21](_v_images/_图21_1525967315_5417.png)<br>
            图2.1<br>
        2->创建3D Super Text Mesh  如图2.2<br>
 ![图2.2](_v_images/_图22_1525967339_671.png)<br>
                             图2.2<br>

我创建了一个UI SuperTextMesh创建之后如下图2.3：<br>
 ![图2.3](_v_images/_图23_1525967356_1770.png)<br>
        图2.3 <br>
        
**3:图文混排的实现**<br>

  在text上输入<q=face>就可以显示出图片来.实现了图文混排，如上图3.1所示<br>
![图3.1](_v_images/_图31_1525967373_26100.png) <br>
                            图3.1
                         
Game窗口显示效果：<br>
![图3.2](_v_images/_图32_1525967388_20288.png) <br>
               图3.2<br>

“face”是face.asset文件；SuperTextMesh里的资源加载方式是通过Resources.Load();<br>
如果需要修改加载资源方式,可以在SuperTextMeshData类文件修改。<br>
创建.asset文件->在Project里的Resource文件夹右击->Create->Super Text Mesh  出来的Data数据就是你可以创建的数据文件了，<br>
如下图3.3，3.4所示：<br>
 ![图3.4](_v_images/_图34_1525967403_24976.png)  
                                   图3.3  <br>        
   ![图3.4](_v_images/_图34_1525967419_23479.png)<br>
                                   图3.4<br>
                            
SuperTextMesh里面的相关参数的使用官方文档里有详细的解释，我在这里就不赘述了，<br>
以下是文档链接:<br>
[SuperTextMesh官方文档](http://supertextmesh.com/docs/SuperTextMesh.html)<br>

接下来说下根据我公司的项目需求对源码做了哪些扩展。<br>

**1:显示方面**<br>
    size:  可以在.asset文件上,或者通过<s=1.2f>修改size(是个比例值，相对于被插入的文本的大小),默认是1；<br>
         如果需要设置size，会涉及到一个位置偏移的问题,需要设置.asset文件上的offset参数，<br>
        目前size设置的是1.2 offset.y : -0.2(具体根据实际情况设置)<br>
        
**2：颜色格式**<br>
        SuperTextMesh里的颜色格式是<c=name></c>或者<c=hexcolor></c>hexcolor不包括 #，0x的字符检测。<br>
     结合项目的需求，添加了<color></color>的颜色格式，在检测颜色字符里添加了“#，x0”
     
**3：加载资源**<br>
         Super Text Mesh的例子中加载.asset文件是通过Resource.load加载的(.asset文件，SuperTextMesh预制体)，<br>
项目中目前使用的是assetBundle的异步加载，<br>
        **1>:**  目前将.asset文件修改为异步加载了 ， LoadQuadAssets.cs<br>
        **2>:**  SuperTextMesh预制体目前还是使用Resource.Load加载<br>
        
**4:布局排版问题**<br>
      **1.6版本:** 之前用的1.6版本布局排版有问题)我们聊天有个需求是背景框会根据聊天内容来调整背景框的宽高使用layout，<br>
      在设置HorizontalLayoutGroup下，Super Text Mesh的width height一直是 0 导致背景框无法做相应的缩放<br>
    **1.7.1版本:** 2018年4月27日发布的1.7.1 支持自定义布局,需要对应加入ContentSize Fitter；Super text mesh 没有在代码里修改过 height，<br>
 width会随着Content Size Fitter的控制为变化;SuperTextMesh里的height 有一个作用是这个文本框的最大垂直空间，如果rect.height的值为0 则无限制<br>
           **问题:**对于我们项目来说，有一个问题:我们是需要根据文本的行数去动态的设置文本背景框的宽高， 这个是根据text 的height值来进行变化的，<br>所以需要我们通过代码来设置height， <br>
解决：在text上添加一个layout element组件，我们可以根据super text mesh里的本文的边框来计算出来文本框的高度，RecalculateBounds()方法里重新<br>计算边框的四个点，可以通过这四个点计算出宽高，然后写一个委托把值传到layout element里，就可以了.<br>

**5.不同分辨率适配：**<br>
     如果项目中的Canvas的 Canvas Scaler mode为 Scale With Screen Size ，那么text的显示就会跟分辨率有关系<br>
原因：text的虚拟边框的数据跟所在跟自身以及所有父节点的scale有关系， Super Text Mesh代码中在计算边框时使用到了Transform.TransformPoint，<br>而TransformPoint是跟自身以及所有父节点的scale值有关系,所以如果需要获取text的虚拟边框值，需要注意下这点。<br>
 ![图6.1](_v_images/_图61_1525967441_18160.png)<br>
                     图6.1   蓝色框时虚拟框<br>
 ![图6.2](_v_images/_图62_1525967460_29039.png)<br>
                    图6.2   计算边框代码位置<br>

最后： 图文混排在SuperTextMesh只是冰山一角，有时间实践下其他的功能.<br>
